#include "VIRQ.H"
#include "PIC.H"
#include "DPMI/DPMI.H"
#include "UNTRAPIO.H"
#include "DPMI/DBGUTIL.H"
#include <dos.h>
#include <dpmi.h>

static int VIRQ_Irq = -1;
static uint8_t VIRQ_ISR[2];
static uint8_t VIRQ_OCW[2];

#define VIRQ_IS_VIRTUALIZING() (VIRQ_Irq != -1)

void VIRQ_Write(uint16_t port, uint8_t value)
{
    //_LOG("VIRQW:%x,%x\n",port,value);
    if(VIRQ_IS_VIRTUALIZING())
    {
        _LOG("VIRQW:%x,%x\n",port,value);
        if((port&0x0F) == 0x00)
        {
            int index = ((port==0x20) ? 0 : 1);
            VIRQ_OCW[index] = value;

            if(value == 0x20) //EOI: clear ISR
            {
                VIRQ_ISR[index] = 0;
                return; //don't send to real PIC. it's virtualized
            }

            if(value == 0x0B) //read ISR
                return; //don't send to real PIC, will be handled in VIRQ_Read.
        }
        return;
    }
    // in case interrupts got enabled disable them before sending EOI to PIC.
    // the interrupt proc will ( should? ) run an STI just before the IRET.
    //  else if ( (port == 0x20 || port == 0xa0 ) && value == 0x20 )
    //      asm("cli");

    UntrappedIO_OUT(port, value);
}

uint8_t VIRQ_Read(uint16_t port)
{
    if(VIRQ_IS_VIRTUALIZING())
    {
        _LOG("VIRQR:%x\n",port);
        if((port&0x0F) == 0x00)
        {
            int index = ((port==0x20) ? 0 : 1);
            if(VIRQ_OCW[index] == 0x0B)//ISR
            {
                //_LOG("VIRQRV: %x\n",VIRQ_ISR[index]);
                return VIRQ_ISR[index];
            }
            //return VIRQ_OCW[index] == 0x0B ? VIRQ_ISR[index] : UntrappedIO_IN(port);
        }
        //_LOG("VIRQRV: 0\n");
        return 0;
    }
    return UntrappedIO_IN(port);
}

void VIRQ_Invoke(uint8_t irq)
{
    _LOG("CALLINT %d\n", irq);
    //CLIS();
    int mask = PIC_GetIRQMask();
    PIC_SetIRQMask(0xFFFF);
    VIRQ_ISR[0] = VIRQ_ISR[1] = 0;
    if(irq < 8) //master
        VIRQ_ISR[0] = 1 << irq;
    else //slave
    {
        VIRQ_ISR[0] = 0x04; //cascade
        VIRQ_ISR[1] = 1 << (irq-8);
    }
    
    VIRQ_Irq = irq;
#if 0
    DPMI_REG r = {0};
    r.w.flags = 0;
    r.w.ss = r.w.sp = 0;
    /* this approach makes HDPMI call the "previous" real-mode handler, that is the handler
     * that was installed when HDPMI has been launched. That's why this strategy isn't successful here.
     */
    DPMI_CallRealModeINT(PIC_IRQ2VEC(irq), &r);
#elif 1
    DPMI_REG r = {0};
    r.w.flags = 0;
    r.w.ss = r.w.sp = 0;
    /* this approach works so long as HDPMI=1 is NOT set. It has the other disadvantage that, if a protected-mode
     * handler is installed, 4 extra mode switches are triggered (PM->RM->RMCB->RM->PM).
     */
    int n = PIC_IRQ2VEC(irq);
    r.w.ip = DPMI_LoadW(n*4);
    r.w.cs = DPMI_LoadW(n*4+2);
    DPMI_CallRealModeIRET(&r);
#else
    /* launching INTs directly would avoid 4 mode switches if a protected-mode handler has been installed.
     * the problem is that real-mode handlers installed in real-mode won't get called then, because HDPMI
     * routes these calls to the interrupt handlers found when HDPMI was installed.
     *
     * A general problem: if the interrupt is handled in real mode, EOIs sent to the PICs cannot be trapped!
     */
    if(irq == 7)
        asm("int $0x0F");
    else
        asm("int $0x0D");
#endif

    VIRQ_Irq = -1;
    CLIS(); /* the ISR should have run a STI! So disable interrupts again before the masks are restored */

    _LOG("CPU FLAGS: %x\n", CPU_FLAGS());
    PIC_SetIRQMask(mask);
    /* don't enable interrupts - this proc is called by
     * the real sound hw interrupt proc.
     */
    //STIL();
    _LOG("CALLINTEND\n");
}
